# 计算机网络

⚠️非常重要

👑重要

⭐️一般

📎了解

## ⚠️OSI七层模型

| OSI七层模型 | 功能                                                       | 协议                        |
| ----------- | ---------------------------------------------------------- | --------------------------- |
| 应用层      | 应用软件所使用的协议，规定了应用软件该以何种方式进行通讯。 | HTTP，SMTP，DNS，FTP等      |
| 表示层      | 决定数据的展现形式，如图片该使用JPEG、BMP还是PNG。         | 没有协议                    |
| 会话层      | 解除和建立与别的端点间的连接。                             | 没有协议                    |
| 传输层      | 提供端对端的接点（端口号这里给出），将数据斩件成小段。     | TCP，UDP                    |
| 网络层      | 为数据包选择路由（路由选路）                               | IP等                        |
| 数据链路层  | 传输有地址的帧以及错误检测功能                             | PPP，ARP等                  |
| 物理层      | 将数据以二进制的形式在物理媒介上进行传输                   | ISO2110，IEEE802，IEEE802.2 |

## 👑TCP/IP的四层模型

应用层：向用户提供数据加上编码和对话控制

传输层：支持不同设备间通过不同网络通信

网络层：确定通过该网络的最佳路径

网络接入层：控制组成网络的硬件设备和介质

## 👑OSI和TCP/IP的区别

- OSI 有七层，而 TCP/IP 有四层
- 在 OSI 中，首先开发模型，然后开发每一层的协议。在 TCP/IP中，首先开发协议，然后开发模型
- OSI模型是基于每一层功能的通用模型，TCP/IP模型是一种面向协议的标准
- OSI模型区分了三个概念，即服务、接口和协议。TCP/IP在这三者之间没有明确的区别
- OSI 模型提供了有关如何进行通信的指南，而 TCP/IP模型则制定了 Internet 开发的标准。因此，TCP/IP 是一种更实用的模型

## HTTP

### ⚠️HTTP概述

HTTP称为超文本传输协议，其特性为：无连接无状态｜构建于TCP/IP协议之上，默认端口号是80

**超文本：**超越普通文本，是文字、图片、视频等混合体。

**传输：**计算机世界中两点之间传输数据。

**协议：**程序见用于传输所需要遵守的规范。

其特性为：无连接无状态明文传输｜构建于TCP/IP协议之上，默认端口号是80

**无状态：**同一个客户第二次访问同一个服务器上的页面时，服务器响应与第一次被访问时的相同。服务器不需要额外的资源来记录状态信息（cookie+session可以解决无状态）。

**明文传输**：传输内容不加密

**不安全：**可以使用HTTPS的方式解决

### ⚠️HTTP状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 100    | 服务器收到部分请求，允许请客户端继续发送请求                 |
| 101    | 服务器根据客户端的请求切换协议                               |
| 200    | 请求成功，非HEAD请求响应头中会有body数据                     |
| 201    | 请求成功，并创建新资源                                       |
| 202    | 已接受请求，但尚未处理。（异步操作最适合状态码）             |
| 203    | 服务器已成功处理了请求，但是返回的实体头部元信息来自本地或者第三方拷贝 |
| 204    | 请求成功，响应头中没有body数据                               |
| 205    | 请求成功，响应头中没有body数据，重制文档视图                 |
| 206    | 请求成功，但是body中不是全部资源（应用于HTTP分块下载或断点续传） |
| 300    | 从返回的多个地址中选择一个进行重定向                         |
| 301    | 永久重定向，请求的资源不存在，需改用新的URL再次访问          |
| 302    | 临时重定向，请求资源还在，但暂时需要用另一个URL来访问        |
| 303    | 对应当前请求的响应可以在另一个URL上被找到，客户端应当采用GET的方式访问那个资源 |
| 304    | 命中缓存（协商缓存？），不具有跳转意义，重定向已存在的缓存文件 |
| 400    | 客户端请求报文有误                                           |
| 401    | 当前请求需要用户验证（一般使用token时常见）                  |
| 402    | 为将来某个需求预留                                           |
| 403    | 服务器禁止客户端访问资源                                     |
| 404    | 客户端请求的资源在服务器上不存在                             |
| 500    | 服务器发生错误                                               |
| 501    | 服务器不支持当前请求所需要的某个功能                         |
| 502    | 服务器自身工作正常，访问后端服务器发生了错误                 |
| 503    | 服务器当前很忙，暂时无法响应                                 |

### ⚠️HTTP请求

| 请求    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求从服务器获取资源，是安全幂等的                           |
| HEAD    | 和GET请求功能相同，但是不返回消息体，只返回请求资源的首部，用于检查超链接的有效性。网页是否被修改（Etag和Last-Modified） |
| POST    | 向URL指定的资源提交数据或附加新数据                          |
| PUT     | 和POST一样，但是PUT是幂等的（相同的多个PUT请求，等同于只发送了一个PUT请求，因为PUT是直接指向修改资源的，而POST是指向修改资源的父级资源） |
| DELETE  | 删除服务器上的某些资源                                       |
| OPTIONS | 获取URL支持的请求方法，如果成功，会返回一个Allow头（包含允许的请求方法） |

### 📎content-type

即Internet Media Type（互联网媒体类型）。通过告知类型让接收方得以进行相应的处理。

| content-type                      | 描述                 |
| --------------------------------- | -------------------- |
| application/xml                   | xml数据格式          |
| application/json                  | json数据格式         |
| application/pdf                   | pdf格式              |
| text/html                         | HTML格式             |
| application/x-www-form-urlencoded | 表单提交数据默认格式 |

### ⚠️HTTP和HTTPS区别

- HTTP使用的**80**端口，HTTPS使用的是**443**端口
- HTTP协议不提供任何方式的数据加密，HTTPS在HTTP协议的基础上加入了**SSL/TSL**协议（在应用层和传输层之间添加了安全层）
- HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### ⚠️HTTPS

- **混合加密（对称加密和非对称加密结合）**

  通信建立前采用非对称加密的方式交换会话密钥，后续将不再使用非对称加密。通信过程中使用对称加密的会话密钥的方式加密明文数据。

  为什么要使用混合加密的方式

  对称加密使用一个密钥，运行速度快，密钥必须保密，无法做到安全的密钥交换。非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度慢。

- **摘要算法**

  要来验证数据的完整性

  传输之前将明文使用摘要算法进行加密生成摘要，然后加明文和摘要通过会话密钥进行加密后传输给对方，对方使用会话密钥解密之后，对明文再次进行摘要算法，对比先后生成的摘要是否一致来验证传输数据的完整性

- **数字证书**

  1.<font color="\#DC143C">服务器</font>将自己的<font color="\#DC143C">公钥</font>注册到CA

  2.<font color="\#00FFFF">CA</font>将自己的<font color="\#00FFFF">私钥</font>将服务器的<font color="\#DC143C">公钥</font>进行数字签名，并颁发证书

  3.客户端使用<font color="\#00FFFF">CA</font>的<font color="\#00FFFF">公钥</font>对数字证书确认真实性，并获取服务器的<font color="\#DC143C">公钥</font>

  4.通过服务器的<font color="\#DC143C">公钥</font>加密报文发送给服务器

  5.服务器通过<font color="\#DC143C">私钥</font>对报文解密

### ⚠️HTTPS流程

- 建立TCP连接（三次握手）
- 客户端发送请求：包含（客户端生成的随机数C、客户端TSL版本号、密码套件列表）
- 服务器发送确认，服务端发送请求：包含（服务端生成的随机数S，确认TSL版本号、使用密码套件（RSA）），服务器发送请求：服务器使用的数字证书（CA所颁发的）
- 客户端通过使用CA的公钥校验数字证书取出服务器的公钥
- 客户端发送请求：包含服务器公钥加密后的pre-master-key
- 服务器通过私钥去取pre-master-key
- 最后会话密钥=客户端随机数+服务器随机数+pre-master-key(48位随机字符/RSA和DH算法生成)
- 后续的https请求均使用会话密钥进行加密
- 断开TCP连接（四次握手）

在https流程中，通过中间拦截信息仅能获取：客户端随机数C，服务端随机数S。所以无法读取通过会话密钥加密后的内容。

### ⚠️HTTP各版本差异

**HTTP1.0和HTTP1.1的区别**

- HTTP1.1默认是持久化连接的，HTTP1.0默认是短连接的（即每次与服务器交互，都需要新开一个连接）
- 管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求。在HTTP1.0中，发送一次请求时，需要等待服务器响应了才可以继续发送请求。在HTTP1.1中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来一一接收
- (pipelining仅限在理论场景下，大部分桌面浏览器仍然会关闭pipelining，开多个TCP连接)
- HTTP1.1增加host字段
- 实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输），成功返回206

存在问题：无论是管线化还是非管线化，均存在线头阻塞的情况

**HTTP1.1和HTTP2.0的区别**

- 二进制分帧

  HTTP2.0将响应报文划分为两个帧，二进制编码的形式（HEADERS首部和DATA消息负载）

  其中帧结构中有流标识符，能够表明属于哪个流，有了他接受方可以从乱序的帧中找到相同的流标识符，从而有序组装信息

- 解决了线头阻塞问题（多路复用）

  多个流复用一个TCP连接，同一个Message内部的帧必然是有序的，并且帧中标记着属于哪一个流，因此同时发送多个流的时候，接受方能够知道请求中的帧属于哪个流

  一个TCP连接中包含多个Stream

  一个Stream中包含1个或多个Message（请求或响应）

  Message中包含一条或者多个Frame

  客户端中的Stream ID为奇数，服务器的Stream ID必须是偶数

  ![image-20220807154526020](/Users/louyangbo/Library/Application Support/typora-user-images/image-20220807154526020.png)

- 头部压缩

  客户端和服务端均维护一张header fields表，通过使用索引号来代替头信息字段，可以减少重复内容重复发送。

- 服务器推送

  改进传统的请求-应答工作模式，服务器可以主动向客户端发送请求（如客户端请求html文件的时候，服务器可以主动向客户端发送css和js文件）

存在问题：HTTP2.0多个请求公用一个TCP连接，一旦其中某个请求出现丢包情况，触发TCP重传机制，所有的请求都必须等待这个丢了的包被重传回来

**HTTP2.0和HTTP3.0的区别**

- HTTP3.0将TCP协议改为UDP协议，因为UDP不管顺序也不管丢包，所以不存在线头阻塞和丢包等待重传问题。并且可以使用QUIC洗衣将UDP封装成可靠传输

### ⚠️HTTP缓存

1⃣️**强缓存：**

会有请求，但是不会向服务器发送请求，直接从缓存中读取资源，会有一个响应为200（from disk cache)的。

响应头：

- **Expires**（http1.0）：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

- **Cache-Control**（http1.1，优先级更高）：当值设为max-age=300时，表示五分钟内再次加载资源，就会命中缓存

2⃣️**协商缓存（对比缓存）：**

需要向服务器发送header请求，服务器根据请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源。

请求头：

- **If-None-Match**（可靠性优先）：存放ETag的值。

- **If-Modified-Since**（性能优先）：存放Last-Modified的值。

响应头：

- **ETag**（可靠性优先）：是对资源的一种唯一标识，只要资源内容有变化，ETag就会重新生成。

- **Last-Modified**（性能优先）：是资源文件最后一次更改时间（时间单位是秒，如果1秒内修改N次，则Last-Modified不会做出变化）。

**浏览器缓存过程：**

1.浏览器第一次发送请求加载数据，服务器返回200，将资源文件从服务器下载下来，并保存响应头中的Cache-Control和Expires

2.下一次需要加载资源时，先比较当前时间与上一次返回200时的时间差，如果没有超过Cache-Control设置的max-age，则没有过期，命中强缓存，不发送请求直接从本地缓存中读取文件（如果不支持HTTP1.1，则用Expires判断是否过期）

3.如果时间过期，服务器则查看header里的If-None-Match和If-Modified-Since

4.服务器优先根据ETag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回 200。（如果没有ETag则对比last-modified）

**用户行为对浏览器缓存的控制：**

1.地址栏访问：正常缓存流程。

2.F5刷新：跳过强制缓存，但是会进行协商缓存。

3.ctrl+F5强制刷新：跳过强缓存，跳过协商缓存，如同第一次一样向服务器拉取资源。

**如何不缓存：**

```
Cache-Control: no-cache（对资源会使用缓存，但每次使用缓存前需要向服务器对缓存资源进行验证）, no-store（不使用任何缓存）, must-revalidate
```

```
Expires：（设置当前时间之前）
```

```
//在引用js、css文件的url后边加上 ?+Math.random()
<script type=“text/javascript” src=“/js/test.js?+Math.random()”></script> 
```

```
//设置html页面不让浏览器缓存的方法
<meta http-equiv="pragma" content="no-cache"> 
<meta http-equiv="Cache-Control" content="no-cache, must-revalidate"> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 00:00:00 GMT">
```

## DNS

DNS(Domain Name System)是“域名系统”的英文缩写，提供将域名和IP地址相互映射的服务，DNS是应用层协议，他是为其他应用层协议工作的，包括并不限于HTTP和SMTP以及FTP，具体将用户提供的主机名解析为ip地址。所有DNS请求和回答报文使用的UDP数据报经过端口53发送

### ⚠️DNS的解析流程

如果查找www.baidu.com

- **浏览器缓存：**浏览器先检查自身缓存中有没有这个域名对应的IP地址，如果有，完成域名解析。
- **本地hosts文件：**操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
- **本地DNS客户端缓存：**如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
- **本地DNS服务器配置区域资源：**（能上qq不能上网，是DNS解析器里面的DNS服务器地址错了）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有**权威性**。
- **本地DNS服务器缓存：**如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析是**非权威**的。
- **迭代查询：**本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址baidu.com给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到www.baidu.com主机。

### ⭐️DNS解析优化

- **减少DNS查找：**

使用浏览器DNS缓存、计算机DNS缓存、服务器DNS缓存，防止DNS迭代查找｜使用Keep-Alive特性来减少DNS查找的频率｜使用较少的域名（服务器）来减少DNS查找的数量

服务器查找返回的DNS记录包含TTL（存活时间，用于告诉客户端该记录可以缓存多久），操作系统会考虑TTL，但是浏览器会忽略该值，并设置自己的时间限制。HTTP协议中的Keep-Alive特性可以同时覆盖TTL和浏览器的时间限制（只要还保持着TCP连接打开状态，那么就不会进行DNS查询）。浏览器对DNS记录缓存数量有限制，未到时间，但是超出限制的最老一批记录将会被遗忘。

- **在前端代码中添加DNS预解析：**

开启/关闭自动解析功能：

```javascript
<meta http-equiv="x-dns-prefetch-control" content="on">
// off 则是关闭
```

手动添加解析：

```javascript
<link rel="dns-prefetch" href="http://www.google.com">
```

## TCP和UDP

### ⚠️TCP和UDP的区别

**用户数据报协议UDP：**

是无连接的；尽最大可能交付；不能保证数据顺序；没有拥塞控制；面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）；支持一对一、一对多、多对一和多对多的交互通信。

**传输控制协议TCP：**

是面向连接的；提供可靠交付；保证数据顺序（由于使用序号）；有流量控制；有拥塞控制；提供全双工通信；面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）；仅支持一对一。

### 📎TCP和UDP应用

TCP：要求通信数据的完整性和准确性较高（文件传输、邮件发送、重要状态的更新）

UDP：要求通信响应度高，对数据信息的安全性和完整性要求较低（网络电话、网络视频）

### ⭐️字节流和报文段

区分字节流和报文关键在于：对使用协议的用户而言，读数据的时候，是不是有“边界”，有边界就是报文，没有边界就是字节流

没有边界：上层协议读取数据的时候不知道读到了几个TCP数据包（因为有缓冲池，所以发送端发送数据和接收端处理数据的频率是可以不对等的）

有边界：上层协议每一次读取必定是一个数据包（没有缓冲池）

### 📎TCP粘包

TCP的粘包并不是TCP协议的问题，是上层应用在处理存储在缓存池中通过TCP传输过来的不同大小不同格式的数据包时，如果此时一次性获取了多个数据包，此时上层应用无法对该数据块，按照不同的数据包进行拆分。这种现象就是TCP粘包。

发送方：关闭Nagle算法。接收方：没法处理，只能交给应用层来进行处理

应用层：

- 使用标准的应用层协议（http，https等）来封装要传输的不定长的数据包
- 在每条数据的尾部添加特殊字符，如果遇到特殊字符表明当条数据接受完毕
- 在发送数据前添加包头，数据格式为：数据头+数据块

### ⚠️TCP三次握手

- A 向 B 发送连接请求报文，***SYN=1，ACK=0，seq=x***。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，***SYN=1，ACK=1，ack=x+1，seq= y***。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，***ACK=1，ack= y+1，seq=x+1***。

第二次握手完成后SYN将被置为0，第三次握手可以携带数据，前两次不可以携带数据。

**为什么需要三次？**

- 最少三次才能同步双方的初始序列号
- 避免资源的浪费，如果两次就建立连接，那么客户端重复发送多次请求，服务端收到，给客户端发请求的同时就需要建立起连接，多个连接会造成重复分配资源。
- 阻止重复历史连接的初始化，客户端在发出首次请求之后，有一次主导权更改建立的初始化序列号

### ⚠️TCP四次挥手

- 客户端发出连接释放报文段（***FIN=1，序号seq=u***），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 服务端收到连接释放报文段后即发出确认报文段（***ACK=1，确认号ack=u+1，序号seq=v***），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 服务端没有要向客户端发出的数据，服务端发出连接释放报文段（***FIN=1，ACK=1，序号seq=w，确认号ack=u+1***），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 客户端收到服务端的连接释放报文段后，对此发出确认报文段（***ACK=1，seq=u+1，ack=w+1***），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

**为什么是四次：**

这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

**为什么需要等待2个MSL**

防止主动接受方发送的最后确认报文，被动接受方没能接受到，触发被动接受方的超时重传，一来一回刚好两个2MSL

MSL为报文最大生存时间，他是任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃，被接收方处理后又向发送方发送响应，一来一回需要等待2倍的时间

**为什么第二次挥手和第三次挥手不能合并成一次**

服务器需要先应答接受到了客户端需要断开的请求，但是服务器可能还有数据需要处理和发送，并且TCP具有一端在结束它发送后仍能接受数据的能力，因此服务器还能向客户端进行发送数据

### 👑TCP可靠传输

TCP通过**重传机制**、**流量控制**、**拥塞控制**来实现可靠传输

#### 重传机制

| 重传机制 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 超时重传 | 超出一定时间没有收到响应触发重传机制                         |
| 快速重传 | 连续收到三次相同的ACK触发重传机制                            |
| SACK     | TCP的字段中添加SACK，显示哪些数据被接收到                    |
| D-SACK   | 用SACK字段表明哪些数据被重复接收，用ACK表明哪些字段丢失，可以用来检测是响应丢失还是请求丢失 |

#### 流量控制

通过使用**滑动窗口**来进行流量控制

- 滑动窗口的大小就是指发送方无需等待确认应答，而可以继续发送数据的最大值

- 滑动窗口的大小是由接收方的窗口大小决定的：接收方告诉发送方自己有多少缓冲区可以接收数据，发送方根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来
- 初始滑动窗口的大小=缓存池中数据量+动态变动后的滑动窗口大小

注意事项：

- 接收方需要更改滑动窗口的大小时，需要先发送更改大小的请求，然后在变更大小
- 如果窗口大小为0的时，需要设置自动发送询问报文来询问接收方是否缓存池有可用大小（窗口关闭问题）
- 滑动窗口过小的时候，不进行数据发送，等窗口恢复到一定大小时再进行发送（糊涂窗口综合症）

#### 拥塞控制

根据网络环境（是否丢包）使用**拥塞窗口**进行拥塞控制，拥塞控制算法如下

- 慢启动

  拥塞窗口<=慢启动门限：拥塞窗口呈指数型增长

- 拥塞避免算法

  拥塞窗口>=慢启动门限：拥塞窗口呈线性增长

- 拥塞发生算法

  出现丢包时：

  使用**超时重传**：慢启动门限=拥塞窗口/2｜拥塞窗口=1｜重新启动慢启动

  使用**快速重传**：拥塞窗口 = 拥塞窗口/2｜慢启动门限 = 拥塞窗口｜进入快速恢复算法

- 快速恢复

  拥塞窗口 = 慢启动门限+3，通过重传一个包。

  如果接收到重复的ACK的话，那么拥塞窗口+1，继续重传

  如果是新的ACK，进入拥塞避免算法

## IP

IP的作用是在复杂的网络环境中将数据包发送给最终目的的主机

### ⭐️IP划分

**IP划分的优势**

如果网络号相同表示在同一个本地网络上，可以直接把数据包发送到目标主机。如果不同，网络号也可以配合路由来进行寻址工作。

**ABCDE类**、**CIDR**、**子网掩码**均可对IP进行分类

- ABCDE类网络

  ABC类划分为网络号+主机号，分别A类1+7+24，B类2+14+16，C类3+21+8

  D类用于多播

  E类保留

  主机号全为1表示广播（本地广播和直接广播），主机号全为0表示某个网络

  优势：ABC类的划分，可以仅仅依靠头部几位数字判断出是哪类网络，并可以很快找出网络地址和主机地址

  缺点：ABC类不能很好的实现显示网络匹配，C类太少，B类太多

- CIDR

  32位地址仅被划分为**网络号**+**主机号**：a.b.c.d/x(前x位是网络号)

  有点：用于很好的实现主机数目的划分

- 子网掩码

  既可以用来划分**网络号**+**主机号**，又可以进一步划分主机号，划分为**子网网络地址**+**子网主机地址**

  优势：通过划分子网，可以1.节约IP地址，避免浪费。2.提高网络性能。3.可以保证网络的安全。4.易于扩大地理范围，有助于覆盖大型地理区域。

### 📎公/私有IP

ipconfig查出来的是私有IP，只能在局域网中使用，不能上网。

百度搜索出来的是共有IP，能上网，一般是运营商的。

### 📎NAT

- NAT

  私有IP在对外部通信的时候，将私有IP转化为NAT路由器的公有IP

- NAPT

  私有IP在对外部通信的时候，将私有IP转化为NAT路由器的公有IP+独一无二的端口号（并将私有IP和公有IP+端口号记录在转换表中，连接结束以后再转换表中删除）

  缺点：

  1.外部无法主动与NAT内部服务器建立连接，因为NAPT转换表没有转换记录

  2.转换表的生成与转换操作都会产生性能的开销

  3.通信过程中，如果NAT路由器重启，所有TCP连接都将被重制

  解决方法：

  NAT穿透技术：客户端主动从NAT设备获取公有IP地址，然后自己建立端口映射条目，然后用这个条目对外通信。

## 浏览器存储

### ⚠️Cookie

- Cookie 是一些数据, 存储于你电脑上的文本文件中
- 实现每次HTTP请求都自动带数据给服务器的技术
- Cookie 的作用就是用于解决 "如何记录客户端的用户信息"
- 一般配合Session一起使用：客户端发送账号密码给服务器，服务器通过账号密码生成SessionID给客户端，然后客户端每次请求都附带这个带有SessionID的cookie。

**首部字段**

| 首部字段名称 | 说明                           | 首部类型     |
| ------------ | ------------------------------ | ------------ |
| Set-Cookie   | 开始状态管理所使用的Cookie信息 | 响应首部字段 |
| Cookie       | 服务器接收到的Cookie信息       | 请求首部字段 |

Set-Cookie字段属性

| 属性                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| \<cookie-name>=\<cookie-value> | 一个cookie必须始于一个名称/值对                              |
| Expires=\<date>                | (可选)cookie的最长有效时间                                   |
| Max-Age=\<non-zero-digit>      | (可选)优先级高于Expires，指失效所需经过的秒数                |
| Domain=\<domain-value>         | (可选)指定cookie可以送达的主机名                             |
| Path=\<path-value>             | (可选)将服务器的文件目录（子目录）作为cookie的适用对象       |
| Secure                         | (可选)仅在请求使用SSL和HTTPS协议的时候才会被发送到服务器     |
| HttpOnly                       | (可选)设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由  Document.cookie属性、XMLHttpRequest和Request APIs 进行访问 |
| SameSite=Strict/Lax            | (可选)允许服务器设定一则cookie不随着跨域请求一起发送         |

### ⚠️Cookie和Session区别

- 存储位置：cookie保存在浏览器端；而session保存在服务器端
- 存储方式：cookie只能保存字符串类型，以文本的方式存储（如果没有设置过期时间，会存储在内存中）；session通过类似与Hashtable的数据结构来保存
- 存储大小：cookie小于4kb；session没有大小限制
- 安全性：session大于cookie

### ⚠️LocalStorage 和 SessionStorage 区别

localStorage 和 sessionStorage 属性均允许在浏览器中存储 key/value 对的数据。均是为了弥补cookie所带来的限制，当数据需要严格控制在客户端，并且不需要持续的将数据发回服务器的时候，就需要使用WebStorage

localStorage用于长久保存数据，没有过期时间设置；sessionStorage用于临时保存同一窗口(或标签页)的数据，关闭对应浏览器窗口（Window）/ tab，数据将会被清除。

### ⭐️cookie和webStorage跨域

- sessionStorage：只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享


- localStorage：在所有的同源窗口中都是共享的


- cookie：在所有同源窗口中都是共享的

**实现跨域**

https://www.runoob.com/js/met-win-postmessage.html

1.A使用iframe嵌入B

2.通过B.postMessage(“这里是消息内容”,这里是B的url)

3.B中通过添加message监听事件来获取内容

### 📎localStorage设置过期时间

存储localStorage的同时，存储一个过期时间

```js
localStorage[key] = value
localStorage[`${key}__expires__`] = Date.now() + 1000*60*expired
```

在获取的时候，先取对应的存储时间，如果过期，则删除。没过期再去取对应的值

## 跨域

### ⚠️同源策略/协议

同源：协议（http/https），域名（www.baidu.com），端口(80/90/3000)相同。

同源策略：不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。

**浏览器**浏览器同源策略，造成不能执行其他网站的脚本，是浏览器对javascript施加的安全限制。

### ⚠️jsonp(json with padding)

**原理：**

- 网页中一些标签天生具有跨域能力，如img、link、iframe、script


- html5的script标签默认的type属性是text/javascript，所以里面的内容会被浏览器以JS代码进行执行

**具体实现方式：**通过script标签的src指向一个需要访问的地址，由服务器返回一个预先定义好的JavaScript函数的调用，并且将服务器的数据以该函数的参数的形式传递过来，此方法需要前后端配合

**缺点：**只能发送GET请求，请求错误不会有任何的状态码

### ⚠️CORS

CORS通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行

| CORS头                               | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| Access-Control-Allow-Origin（常用）  | 请求的资源能共享给哪些域                                     |
| Access-Control-Allow-Credentials     | 响应头表示是否可以将对请求的响应暴露给页面。返回true则可以，其他值均不可以。 |
| Access-Control-Allow-Headers（常用） | 表明请求头中除了simple headers以外的哪些HTTP头可以被允许     |
| Access-Control-Allow-Methods（常用） | 指定请求允许的方法（get、post等）                            |
| Access-Control-Expose-Headers        | 表明响应头中除了simple response headers以外哪些可以暴露给外部 |
| Access-Control-Max-Age               | 返回的结果可以被缓存多久                                     |
| Access-Control-Request-Headers       | 用于通知服务器在真正的请求中会采用哪些请求头                 |
| Access-Control-Request-Method        | 用于通知服务器在真正的请求中会采用哪些请求方法               |
| Origin                               | 请求来自哪个站点                                             |

CORS根据请求方式和请求头的不同，可以将CORS请求氛围两大类

**简单请求：**

1.请求方式GET、POST、HEAD三者之一

2.请求头无自定义头部字段

**预检请求：**（在发送正式请求前，先会发送OPTION请求进行预检，如果服务器允许，则继续发送真正的请求）

1.请求方式为GET、POST、HEAD之外的请求Method类型

2.请求头中包含自定义头部字段

3.向服务器发送了application/json格式的数据

## ⚠️URL输入到渲染

1.在浏览器地址栏中输入URL

2.浏览器强缓存检查

- 如果命中Expires（日期）和Cache-Control（最大新鲜时长）所指定的缓存有效期，也会返回（200 from disk cache）
- 未命中或没有缓存，则发起请求

3.浏览器解析URL获取协议、主机、端口号、path等，组装一个HTTP请求（GET）报文

4.DNS解析流程，获取主机IP地址

- 浏览器缓存->本地hosts文件->本地DNS解析客户端（缓存）->本地DNS解析服务器（区域配置资源，权威）->本地DNS解析服务器（缓存，非权威）->DNS递归查找

5.打开一个socket与目标IP地址建立TCP连接

- 客户端发送TCP连接请求（SYN=1，seq=x，ACK=0）
- 服务器发回（SYN=1，seq=y，ACK=1，ack num=x+1）
- 客户端发回（SYN=0，seq=x+1，ACK=1，ack num=y+1）

6.发送HTTP请求，如果是HTTPS请求，则进行如下操作，获取会话密钥

- 客户端发送请求（随机数C，客户端TSL版本号列表，密码套件列表）
- 服务器发回1.确认响应2.包含（随机数S，TSL版本号，密码套件）3.CA颁发的数字证书
- 客户端使用CA公钥获取数字证书中的服务器公钥，发回使用公钥加密的pre-master
- 服务器使用私钥解密出pre-master，双方通过C+S+pre-master生成的会话密钥通信

7.浏览器协商缓存检查

- 服务器根据请求中的If-None-Match（上次响应中的Etag）和If-Modified-Since（上次响应中的Last-Modified）判断文件是否变动，如果没变动，命中协商缓存，返回304

8.服务器通过TCP连接将响应报文发送回浏览器

9.浏览器接收到HTTP响应后，断开TCP连接

- 客户端发送（FIN=1，seq=x）
- 服务器发回（seq=y，ACK=1，ack num=x+1）
- 服务器发回（FIN=1，seq=w，ACK=1，ack num =x+1）
- 客户端发回（seq=x+1，ACK=1，ack num=w+1）

10.浏览器根据HTTP响应不同的的响应码作出不同的处理

11.如果资源可缓存（expires、cache-control），进行缓存

12.对响应进行解码

13.根据资源类型决定如何处理（以下拿HTML文档进行描述）

14.解析HTML文档、构建DOM树、构建CSSOM树、执行JS脚本

- 构建DOM树：Tokenizing字符流转化为标记流->Lexing标记转换为对象->DOM construction对象转换为DOM树
- 构建CSSOM树：Tokenizing字符流转换为标记流->Node根据标记创建结点->结点创建CSSOM树
- JS脚本执行：创建Document对象，将解析HTML得到的元素和文本结点添加到文档中，script｜async script｜defer script标签的执行

15.构建渲染树->布局->绘制

- 构建渲染树：从DOM树的根结点遍历所有可见结点（script，meta，display：none除外），对每个课间节点找到CSSOM规则并应用，发布可视节点的内容和计算样式

16.显示页面

## ⚠️JWT

JWT（JSON Web Tokens）一切以token为核心，JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源

**token结构**

http://121.5.179.205:3000/posts/7

**token的存储问题**

- **cookie**

  让它自动发送，不过缺点就是不能跨域

  设置HttpOnly可以防止XSS攻击，但是受到CSRF攻击，不过可以使用Origin字段后端判断是否是正确的域发过来的

- **localStorage**

  每次调用接口的时候放在Http请求头的Authorization字段中

  可以防止CSRF攻击，但是会遭受XSS攻击

## ⭐️CSRF攻击

CSRF：跨站请求伪造（就是用户在第三方网站上向A发送请求，然后携带上了cookie）

解决方案：

1.验证HTTP Referer或者Origin字段：

Referer字段记录了请求的来源地址，而CSRF攻击请求来源地址为第三方网站（但是referer的实现是由浏览器来实现的，不能保证浏览器不存在漏洞）

Referer显示来源页面的完整地址（敏感内容容易暴露），Origin仅仅显示协议+host，不包含路径等信息。

Referer存在于所有请求，而Origin只存在于post请求，Referer可以直接修改删掉，但是Origin可以修改但是无法删除

## ⭐️XSS攻击

XSS简单来说就是在Web页面中插入恶意的Script代码

script标签可以插入代码，img中的onerror也可以

eval（）会将编码之后的语句解码并执行

防御手段：对script、img、a标签进行过滤

较长的输入进行截断

## ⭐️WebSocket

❓诞生的原因

http存在一个明显的弊端：消息只能从客户端推送到服务器端，而服务器端如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是就有了webSocket（H5新增功能）。

❓基本概念：

HTTP的轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接（大部分请求无用，浪费带宽和服务器资源）

HTTP的长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，知道有新消息才返回响应信息并关闭连接（客户端hold连接会消耗资源，返回数据顺序无保证，难以维护）

长连接：http1.1所实现的功能

🔥Websocket介绍

Websocket是一个持久化协议，基于http，服务端可以主动push请求到客户端

## ⭐️正向/反向代理

**正向代理**（科学上网）

代理服务器**拦截**客户端的请求（客户端直接发送到服务器的），然后转发给服务器，在服务器看来，请求是从代理服务器发出来的，可以做到隐藏客户端的身份。

作用：缓存、匿名、访问控制、访问记录

**反向代理**（Nginx ）

代理服务器将客户端的请求转发给服务器（客户端发送到代理服务器），然后代理服务器替你去访问服务器，将数据返回给客户端。对于客户端而言，他不知道数据具体是从那个服务器发出来的

作用：缓存、匿名、负载均衡、灰度发布、路由功能

whistle：（正想代理）

通过雷火的域名代理到本地的localhost，这样就能够在本地请求到测试环境的接口

代理响应内容，快速做mock

支持修改请求的userAgent
